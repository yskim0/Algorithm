# 코드플러스 알고리즘 기초 - 1/2
## 300 - 수학 1


**나머지 연산**

- (A+B) mod M = ((A mod M) + (B mod M)) mod M
- (AXB) mod M = ((A mod M) X (B mod M)) mod M
- (A-B) mod M = ((A mod M) - (B mod M) + M) mod M

- 나누기의 경우는 성립하지 않음(*Modular Inverse*를 구해야 함.)


문제에서 `정답을 ~로 나눈 나머지를 출력하라`라는 말이 있는 이유는 **정답이 int, long long과 같은 자료형의 범위를 넘어가기 때문.**

--- 

**최대 공약수**

- `GCD`
- 2부터 min(A,B)까지 모든 정수로 나누어보는 방법 -> O(N)
- **유클리드 호제법**
    - a를 b로 나눈 나머지를 r이라고 했을 때 GCD(a,b) = GCD(b,r)과 같다.
    - 재귀 함수를 이용한 유클리드 알고리즘
    ```c
    int gcd(int a, int b) {
        if (b==0) {
            return a;
        }
        else {
            return gcd(b, a%b);
        }
    }
    ```
    - 재귀 함수 이용 X
    ```c
    int gcd(int a, int b){
        while (b != 0) {
            int r = a%b;
            a = b;
            b = r;
        }
        return a;
    }
    ```
    - 세 수의 최대 공약수는 `GCD(a,b,c) = GCD(GCD(a,b),c)` 와 같은 형식으로 구할 수 있다.
        - 네 수, N개의 수도 위와 같은 식으로 계속 구할 수 있다. (출제 포인트)


---

**최소 공배수**

- `LCM`
- A X B = GCD X LCM 이므로 LCM = A*B/GCD이다.

---

**소수** (출제 포인트가 정말 많으니 잘 알아둘 것)

- 알고리즘의 종류
    - 어떤 수 N이 소수인지 아닌지 판별하는 방법
    - N보다 작거나 같은 모든 자연수 중에서 소수를 찾아내는 방법

- 소수 판별법
    - N이 소수가 되려면, 2보다 크거나 같고 루트N보다 작거나 같은 자연수로 나누어 떨어지면 안된다.
    ```c
    bool prime(int n) {
        if (n<2) return false;
        for (int i = 2; i*i<=n; i++) {
            if (n%i == 0) {
                return false;
            }
        }
        return true;
    }
    ```
    이 방법은 시간복잡도가 O(루트N)이 된다.
    - 위 방법으로 1부터 1,000,000까지의 모든 소수를 구하는데 걸리는 시간복잡도는 O(N루트N)이 된다.

- **에라토스테네스의 체**
    - 1부터 N까지의 범위 안에 들어가는 모든 소수를 구하려면 에라토스테네스의 체를 사용한다.
    - 프로세스
        - 2부터 N까지의 모든 수를 쓴다.
        - 아직 지워지지 않은 수 중에서 가장 작은 수를 찾는다.
        - 그 수는 소수이다.
        - 그 수의 배수를 모두 지운다.
    - 구현
    ```c
    int prime[100]; // 소수 저장
    int pn = 0; // 소수 개수
    bool check[101]; // 지워졌으면 true. 진짜로 지우는 것은 위험하니 flag 이용
    int n = 100; // 100까지의 소수 
    for (int i = 2; i<=n; i++) {
        if (check[i] == false) {// 지워지지 않았다면
            prime[pn++] = i;
            for (int j=i*i; j<=n; j+=i) {
                check[j] = true;
            }
        }
    }
    ```
    - 위 구현에서 N의 크기에 따라 `i*i`는 `i*2`로 바꾸는 게 좋을 수 있음. (범위를 넘어갈 수 있으니까)
    - O(NloglogN)

- **골드바흐의 추측**
    - 2보다 큰 모든 짝수는 두 소수의 합으로 표현 가능하다.
    - 위 문장에서 3을 더하면 5보다 큰 모든 홀수는 세 소수의 합으로 표현이 가능하다.
    - 10^18 이하에서는 참인 것이 증명되어 있다.


---

**팩토리얼**

- 팩토리얼의 0의 개수
    - N!을 소인수분해 했을 때, 2와 5가 몇 개 나오는지 알아야 한다.
    - 5의 개수가 항상 2의 개수보다 적기 때문에, **5의 개수만 세면 된다.**
    