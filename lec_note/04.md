# 코드플러스 알고리즘 기초 - 1/2
## 400 - 다이나믹 프로그래밍 1

- 큰 문제 -> 작은 문제로 푸는 방법
    - DP : 중복 가능
    - 분할정복 : 중복 X

- 다이나믹 프로그래밍
    - 큰 문제를 작은 문제로 나눠서 푸는 알고리즘
    - 크다 작다? -> 문제의 크기
    - 두 가지 속성을 만족해야 다이나믹 프로그래밍으로 문제를 풀 수 있다.
        - Overlapping Subproblem
        - Optimal Substructure

- Overlapping Subproblem
    - 피보나치 수를 구할 때 중복되는 작은 문제들

- Optimal Substructure
    - 문제의 정답을 **작은 문제의 정답**에서 구할 수 있다.
    - 예. 서울에서 부산을 가는 가장 빠른 길이 대전과 대구를 순서대로 거쳐야 한다면, *대전에서 부산을 가는 가장 빠른 길은 대구를 거쳐야 한다.*
    - **문제의 크기에 상관없이 어떤 한 문제의 정답은 일정하다.**
        - 4번째 피보나치 수는 항상 같다.

- 다이나믹 프로그래밍에서 각 문제는 한 번만 풀어야 한다.
- Optimal Substructure를 만족하기 때문에, 같은 문제를 구할 때마다 정답이 같다.
- 따라서 정답을 한 번 구했으면, 정답을 어딘가에 **메모** 해놓는다.
    - 이런 메모하는 것을 코드의 구현에서는 **배열**에 저장하는 것으로 할 수 있따.
    - `Memoization`

- 피보나치 수
    - 한 번 답을 구할 때, 어딘가에 메모를 해놓고 중복 호출이면 메모해놓은 값을 리턴한다.
    - memo[i] = 0로 우선 초기화 해야 함. 
        - 0이라는 것은 답을 구하지 않음을 의미함
    ```cpp
    int memo[100];
    int fibonacci(int n) {
        if (n <= 1) {
            return n;
        }
        else {
            // memo된 값이 있는지 확인 후, 있으면 해당 값을 리턴함.
            if (memo[n] > 0) { 
                return memo[n];
            }
            memo[n] = fibonacci(n-1) + fibonacci(n-2);
            return memo[n];
        }
    }
    ```
    - 모든 문제를 1번씩 풂. 문제의 개수 X 문제 1개를 푸는 시간
        - 문제의 개수 = N
        - 문제 1개 푸는 시간 = 함수의 시간 복잡도 = O(1)
        - 따라서 시간 복잡도는 `O(N)`

- 다이나믹 구현 방식
    - Top-down
        - 재귀 이용
        - 스택을 사용하기 때문에 스택 오버 플로 가능성
    - Bottom-up
        - 반복문 이용
        - 정말 **모.든** 문제를 풂.
    - 시간차이는 **알 수 없 다!**
    - 파이썬으로 푸는 경우 바텀업이 더 좋음.

- Top-down 방식
    - 모든 문제를 풀어야 한다.
    - 문제를 작은 문제로 나눈다.
    - 작은 문제를 푼다.
    - 작은 문제를 풀었으니, 이제 문제를 푼다.
    - **재귀 호출**을 이용해서 문제를 풀 수 있다.

- Bottom-up 방식
    - 문제를 크기가 작은 문제부터 차례대로 푼다
    - 문제의 크기를 조금씩 크게 만들면서 문제를 점점 푼다
    - 작은 문제를 풀면서 왔기 때문에, 큰 문제는 항상 풀 수 있다
    - 반복하다 보면 가장 큰 문제를 풀 수 있다
    ```cpp
    int d[100];
    int fibonacci(int n) {
        d[0] = 0
        d[1] = 1
        for (int i =2; i<=n; i++) {
            d[i] = d[i-1] + d[i-2];
        }
        return d[n];
    }

---

- 문제 풀이 전략 -> **점화식 정의가 최우선 문제**
    - 문제에서 구하려고 하는 답을 문장으로 나타낸다. (예. 피보나치 수를 구하는 문제)
    - 그 문장에 나와있는 변수의 개수만큼 메모하는 배열을 만듦.
    - Top-down의 경우에는 재귀 호출의 인자의 개수
    - 문제를 작은 문제로 나누고, 수식을 이용해서 문제를 표현

- 문제) 1로 만들기
    - 정수 X에 사용할 수 있는 연산은 세 가지
    - X가 3으로 나누어 떨어지면, 3으로 나눈다
    - X가 2로 나누어 떨어지면, 2로 나눈다
    - 1을 뺀다
    - 어떤 정수 N에 위와 같은 연산을 선택해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최소값을 구하는 문제.
    - **D[N] = N을 1로 만드는 최소 연산 횟수**
        - D[N] = min(D[N/3], D[N/2], D[N-1]) + 1

- 문제) 2 x n 타일링
    - 2 x n 직사각형을 1X2, 2X1 타일로 채우는 방법의 수
    - D[N] = 2 X N 직사각형을 채우는 방법의 수
    - **가장 오른 쪽에 타일을 놓을 수 있는 방법을 생각해야 함** -> 2가지
        - 맨 오른쪽에 세로 타일 하나
            - D[n-1]
        - 맨 오른쪽에 가로 타일 두 개
            - D[n-2]
    - D[n] = D[n-1] + D[n-2]

- 문제) 2 x n 타일링 2
    - 2 x n 직사각형을 1X2, 2X1 , 2X2 타일로 채우는 방법의 수
    - D[i] = 2*D[i-2] + D[i-1]

- 문제) 1,2,3 더하기
    - D[i] = i를 1,2,3의 합으로 나타내는 방법의 수
    - +1 했을 때 n이 되려면 그 전의 합이 n-1이어야 함.
    - +2 했을 때 n이 되려면 그 전의 합이 n-2이어야 함.
    - +3 했을 때 n이 되려면 그 전의 합이 n-3이어야 함.
    - D[i] = D[i-1] + D[i-2] + D[i-3]
    - D[0] = 1

- 문제) 카드 구매하기
    - 카드 N개를 구매해야 하고 카드팩은 총 N가지 종류가 존재한다.
    - i번째 카드팩은 i개의 카드를 담고 있고, 가격은 P[i]원이다.
    - 카드 N개를 구매하는 비용의 최대값을 구하는 문제
    - D[i] = 카드 i개를 구매하는 최대 비용
    - i번째 카드팩을 구매할 때 카드가 몇 개 있는지는 모름.
        - P[i]로 계산
    - D[N] = max(D[N-i] + P[i])

- 문제) 카드 구매하기 2
    - 카드 N개를 구매하는 비용의 최솟값을 구하는 문제
    - D[i] = 카드 i개 구매하는 최소 비용
    - D[i] = min(P[j] + D[i-j]) 이지만 초기값을 조심해야 한다.
    - D를 -1로 초기화

- 문제) 1,2,3 더하기 5
    - 정수 n을 1,2,3의 합으로 나타내는 방법의 수를 구하는 문제
    - 단, 같은 수를 두 번 이상 연속해서 사용하면 안된다.
        - 연속, 증가, 감소 조건들은 다 2개씩 나눌 수 있음.
        - 앞에 있는 수를 빼고 처리
    - D[i][j] = i를 1,2,3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 j
        - j와 같지 않은 수를 사용하기 위해
    - 마지막 사용한 수가 1 
        - D[i][1] = D[i-1][2] + D[i-1][3]
    - 2,3의 경우에도 위 식과 동일한 논리
    - D[0] = 1로 초기화하면 중복 발생 -> 예외 처리 중요
        - D[i][1] 의 경우 i==1 일때 1, 아니면 0
    
