# 코드플러스 알고리즘 기초 - 2/2
## 500 - 브루트 포스

- 브루트 포스
    - 모든 경우의 수를 다 해 보는 알고리즘
    - 문제에서 가능한 방법의 개수를 먼저 세봐야 함. 다 해봤을 때 시간의 제한을 넘지 않을 때 사용

- 3가지 단계 
    - 문제의 가능한 경우의 수 계산
        - 직접 계산. 손으로 계산 가능
    - 가능한 모든 방법을 다 만들어 봄
        - 하나도 빠짐 없이 만들어야 한다
        - 그냥 다 해보는 방법, for문 사용, 순열 사용, 재귀 호출 사용, 비트마스크 사용 등이 있음
    - 각각의 방법을 이용해 답을 구함

- 시간 복잡도
    - O(경우의 수 * 방법 1개를 시도해보는 데 걸리는 시간 복잡도)

- 경우의 수 연습
    - N명의 사람이 한 줄로 서는 경우의 수 : N! => `O(N!)`
    - N명의 사람 중에서 대표 두 명을 뽑는 경우의 수 : NC2 = N*(N-1)/2 => `O(N^2)`
    - N명의 사람 중에서 반장 1명과 부반장 1명을 뽑는 경우의 수 : N*(N-1) => `O(N^2)`
    - N명의 사람이 있을 때 각 사람이 영화를 볼지, 안볼지 결정. 가능한 조합의 수 -> 2^N => `O(2^N)`

---

그냥 다 해보기
- 문제) 일곱 난쟁이 (2309)
    - 아홉 명의 난쟁이 중 일곱 명의 난쟁이를 찾는 문제
    - 일곱 난쟁이의 키의 합은 100이다.
    - 난쟁이가 아닌 2명을 찾으면 됨 -> 9C2 = 36
    - 먼저 sum에다가 9명의 키 합

- 사탕 게임
    - NxN 크기의 테이블에 사탕이 있다. (N<=50)
    - 인접한 두 칸을 고르고, 사탕을 교환한다
    - 그 다음 같은 색으로 이루어져 있는 가장 긴 연속 부분 행 또는 열을 고르는 문제
    - 인접한 두 칸을 고르는 방법의 개수 -> O(N^2)
        - 모든 칸은 4개의 인접한 칸을 가지고 있으므로 O(2N^2)
    - 같은 색으로 이루어져 있는 가장 긴 연속 부분 행 또는 열을 고르는 문제 -> O(N^2)
    - 총 N^4 ... 50^4 => 2500^2 이라 큰 값이 아니다 ㄷ
    - code
        - 이거 어렵다 잘 숙지하자 
    - 시간 줄일 수 있음
        - 안 바꾼 상태에서 정답을 구했다 가정하고, 어느 칸과 인접한 칸을 교환했다고 하면 정답이 바꿀 수 있는 부분은 그 행과 열 -> O(N^3)이 됨.

- 날짜 계산
    - E S M 이라는 연도 사용
    - 가능한 E의 개수는 15
    - 가능한 S의 개수는 28
    - 가능한 M의 개수는 19
    - 전체 경우의 수는 15x28x19 = 7980
        - 보통 1억을 1초라 하니 매우 작은 값

- 리모컨
    - 현재 보고 있는 채널 -> 이동하려고 하는 채널이 N일 때 누르는 최소 횟수
    - **최소를 찾을 때 가장 중요한 부분**
        - **의미없는 것이 있는 방법은 절대 최소가 될 수 없다**
        - **중복이 있는 경우는 절대 최소가 될 수 없다**
    - **숫자 버튼을 누르고, 그 다음 +나 -중 하나만 연속해서 눌러야 한다.**
    - 50만밖에 안되니까 쉽다.
    - 이동하려고 하는 채널은 대략 100만. 100만을 넘지 않겠다고 생각
    - 넉넉하게 100만까지 검사
    - 이동할 채널 C를 정한다
    - C에 포함되어 있는 숫자 중에 고장난 버튼이 있는지 확인한다
        - 수를 문자열로 바꾼 다음 한글자씩 검사하는 방법
        - **수를 10으로 계속해서 나누면서 하나씩 검사하는 방법**
            - 0인 경우 예외 처리
    -  +, - 이동하는 횟수는 |N-C| 더해줌
    - 개어렵다

- 테트로미노
    - 폴리오미노는 크기가 1x1인 정사각형을 여러 개 이어 붙여서 만든 도형
    - 정사각형 4개를 이어 붙인 폴리오미노는 테트로미노라고 하며, 총 5가지가 있다
    - NxM 크기의 종이 위에 테트로미노를 하나 놓아서 놓인 칸에 쓰여 있는 수의 합을 최대로 하는 문제
    - 블럭은 총 19가지 있다고 볼 수 있다. (회전시켜보고~)
    - 먼저 어떤 테트로미노를 놓을건지 결정 -> 어디에 놓을건지 결정 
        - 어떤 것은 19가지 방법
        - 어디에 놓을건지 -> (N-2)x(M-1) 가지... O(NM)
        - 전체 경우의 수 19xNxM => 19x500^2 = 4750000 적은 경우의 수(1억이 1초인데)
    - 코드 ㄷㄷ...

---
건너 뛰며 해보기

- 카잉 달력
    - 날짜 계산이랑 비슷하지만 조금 다름
    - 연도가 2개
    - M, N <=4만. 큼!! => 16억. 16초 정도 나오니까 건너뛰면서 해봐야 함
    - m = 5면 5단위로 반복, n=7이면 7단위로 반복
    - <x:y>이 몇 번째 해인지 구하는 문제
    - <3,6>구하라 했으면 3부터 5칸씩 건너뛴다.
    - 모든값에서 1을 빼고 나머지
        - (i%M, i%N)
    - x = 3, y=2 이면 x=3인 것만 쭉 계산하다보면 언젠간 찾을 수 있을 것..
        - m에 대해 고정했으면 N번만 하면 됨
    - O(N) 안에 가능

- 수 이어 쓰기 1
    - 1부터 N까지 수를 이어서 쓰면 새로운 하나의 수를 얻게 된다
    - 이 때 새로운 수는 몇 자리 수일까?
    - 길이를 구하는 거니까 더 좋은 방법이 있다
        - 1~9 -> 1자리
        - 10 ~ 99 -> 2자리 수
        - 이렇게 나누어볼 수 있음
    - **중복되는데, 공통된 것들이 그룹을 지어 나타난다면 묶어서 한 번에 계산**

- N중 for문
    - N개 중에 일부를 선택해야 하는 경우에 많이 사용
    - 1,2,3 더하기
        - 10중 for문 ...
        - 좋은 방법 X. 재귀함수가 좋다

---

브루트 포스 N과 M

- 재귀 함수의 방식으로 풀어본다
- 브루트 포스에서 방법을 만드는 방법
    - **재귀**
        - 순열, 비트마스크 -> 재귀 가능하기 때문에 중요
        - 순서, 선택과 관련된 문제
    - 순열
    - 비트마스크

- N과 M(1)
    - 1부터 N까지 자연수 중에서 **중복 없이** M개를 고른 수열을 모두 구하는 문제
        - **순서**와 관련된 문제
    - 1 <= M <= N <= 8
    - 가장 앞에부터 수를 하나씩 넣어본다
    - N 중 하나 (N가지), N-1가지
    - index 번째를 채운다... 그 앞에는 다 차있다.
        - 어떤 수를 사용했고, 어떤 수를 사용하지 않았는지 기록할 배열 -> c
            - c[i] = true 사용. false -> 사용 X
    - O(N!)

- N과 M(2)
    - 1부터 N까지 자연수 중에서 중복없이 M개를 고른 수열을 모두 구하는 문제 **(오름차순)**
    - 하나만 변경해야 함
    - *index 번째라 했을 때 N과 M(1)은 1~N 중에서 앞에서 사용하지 않은 수였음.*
    - num을 넣었을 때는 num+1~N 중에서 앞에서 사용하지 않은 수
    - O(N!)

- **N과 M(2) 다른 방법**
    - M개의 수를 골라서 어떤 수가 들어갈지 결정
    - 각각의 수를 선택한다는 관점에서 이 문제를 풀 수 있음.
    - 포함, 포함X
    - O(2^N)
    - **가장 중요한 방법**

- N과 M(3)
    - 중복 선택 가능
    - N과 M(1)에서 중복 처리했던 것 지움

- N과 M(4)
    - 1부터 N까지 자연수 중에서 M개를 고른 수열을 모두 구하는 문제(중복 선택 가능, **비내림차순**)
    - N과 M(2)에서 중복선택 가능만 변경된 것
        - 두 가지 방식으로 했었음
    - 순서 기준 방법
    - 선택 방법
        - 중복이 가능한 문제라 굳이 선택에 대한 문제로 바꾸는 게 좋지 않은 방법... 할 수는 있지만 더 나눠야 함

- N과 M(5)
    - N개의 서로 다른 자연수 중에서 M개를 고른 수열을 모두 고르는 문제

---

순열
- 브루트포스를 풀 때 순서가 매우 중요한 의미를 가지고 있을 때
- 임의의 수열을 다른 순서로 섞는 연산
- **다음 순열**를 구하는 알고리즘을 알아야 함
    - C++, python은 라이브러리에 있음
- 모든 순열은 앞의 어떤 것으로 시작하는 마지막 순열, 그 다음껀 앞의 그 다음 것으로 시작하는 첫 순열
    - 첫 순열 : 오름차순, 마지막 순열 : 내림차순 의미

다음 순열
- A=[7,2,3,6,5,4,1] : 723으로 시작하는 마지막 순열
    - 1,4,5,6 부분은 내림차순인데 723은 오름차순이므로
        - i번째부터 시작하는 내림차순, i-1번째까지로 시작하는 마지막순열이다
- 뒤에서부터 수를 하나씩 비교해서 대수관계가 어긋나는 순간 탐색 종료
    - O(N) : N개 비교
- 다음은 72? 로 시작하는 첫 순열. 3이 커져야 함!
    - 커져야 하는데 무조건 4로 시작해야하는 것이 아니라, 뒤에 있는 수 중 하나로 시작해야 한다.
    - 뒤에 있는 수들 중에서 3보다 크면서 가장 작은 수 => 4

1. A[i-1] < A[i]를 만족하는 가장 큰 i를 찾는다 => O(N)
2. j>=i 이면서 A[j]>A[i-1]를 만족하는 가장 큰 j를 찾는다 => O(N)
3. A[i-1]과 A[j]를 swap 한다 => 7246531
4. A[i]부터 순열을 뒤집는다 => => 7241356 => O(N)
=> 총 시간복잡도가 **순차적으로 걸리는 거니까** O(N)
- 모든 순열을 구하는 데 걸리는 시간 : O(NxN!)

```cpp
bool next_permutation(int *a, int n) {
    int i = n-1;
    while (i>0 && a[i-1] >= a[i]) i-=1;
    if(i<=0) return false; // 마지막 순열
    int j = n-1;
    while (a[j] <= a[i-1]) j-=1;
    swap(a[i-1], a[j]);
    j=n-1;
    while(i<j) {
        swap(a[i], a[j]);
        i+=1; j-=1;
    }
    return true; // 다음 순열이 있음
}
```

- 이전 순열, 모든 순열 코드
    - 모든 순열 구할 때는 do while 많이 사용한다

- 팩토리얼
    - 보통 n이 10이하로 주어짐 (11!부터 엄청 큼)
    - O(N!) 와 O((N+1)!) 는 어마어마한 차이이다


<br>
차이를 최대로
- 수 N개가 주어졌을 때
- |A[0]-A[1]| + |A[1]+A[2]| +...+ |A[N-2]-A[N-1]| 를 최대로 하는 문제
- 제한이 8밖에 안됨
- 수의 순서만 변경할 수 있다 -> 순열
- 8x8! = 32만밖에 안된다


외판원 순회 2
- 한 도시에서 시작해 N개의 모든 도시를 거쳐 다시 원래 도시로 돌아온다
    - 한 번 갔던 도시로는 다시 갈 수 없다
- 이 때 가장 적은 비용을 구하는 문제
- W[i][j] = i -> j 비용 0인 경우는 갈 수 없음
- '모든 도시를 거친다' '한 번 갔던 도시로는 갈 수 없다' -> 순열
- N제한이 10이라서 모든 경우를 살펴봐도 되는 문제가 된다.
- 코드 어렵다.. 복습 필요

로또
- 입력으로 주어진 K개의 수 중에서 6개의 수를 고르는 문제
    - 고르는 것 : 1 x 6
    - 안 고르는 것 : 0 x (k-6)개
    - 위를 이용해서 전체 순열을 만들었다고 한다면, 모든 순열을 만들 수 있음
- 순서를 이용해서 선택을 해결한다
- 같은 수가 있어도 순열을 만들 수 있다
- 이것도 코드는 어려우니까 복습 필요함

---
**재귀**

1,2,3 더하기
- 문제의 제한 N<=10
- N=10 일 때 전체 경우의 수는 3^10
- 어딘가까지의 합을 구해놓고 새로운 값을 추가했을 때 합이 어떻게 변하는지에 대한 재귀 함수
- `go(count, sum, goal)`
    - goal을 만들자
    - 숫자 count개로 합 sum을 만드는 경우의 수
    - count -> count + 1
    - sum -> sum + i
- 브루트 포스 3가지 경우를 생각해야 함
    - **불가능한 경우** : 아무리 재귀 호출을 해도 정답을 절대 못 구하는 경우
        - sum > goal
        - 문제의 조건을 위배하는 경우
    - **정답을 찾는 경우** : 더이상 함수 호출을 이어나갈 필요가 없음
        - sum == goal
    - **다음 경우 호출**
        - count -> count + 1
        - sum -> sum + i

암호 만들기
- 암호는 서로 다른 L개의 알파벳 소문자들로 구성되며 최소 한 개의 모음과 최소 두 개의 자음으로 구성되어 있다.
- 암호를 이루는 알파벳이 암호에서 **증가하는 순서**로 배열되었어야 한다.
    - 각각의 알파벳을 먼저 정렬해두고 포함시킨다/시키지않는다를 구해주면 항상 정렬된 상태
- 암호로 사용할 수 있는 문자의 종류는 C가지 
- 가능성 있는 암호를 모두 구하는 문제
- 3<=L<=c<=15 : 브루트 포스 가능
    - 2^C
- `go(n, alpha, password, i)`
    - n : 만들어야 하는 암호의 길이
    - alpha : 사용할 수 있는 알파벳
    - password : 현재까지 만든 암호
    - i : 사용할지 말지 결정해야 하는 알파벳의 인덱스
- 1) 정답을 찾은 경우 : password의 길이 == n
    - 최소 한 개의 모음과 최소 두 개의 자음으로 구성 -> 나중에 생각
- 2) 불가능한 경우 : 더이상 선택할 수 있는 알파벳이 없는 경우. i >= alpha의 크기
- 3) 다음 경우
    - i번째 경우를 사용하는 경우 -> go(n,alpha, password+alpha[i], i+1)
    - i번째 경우를 사용하지 않는 경우 -> go(n,alpha, password, i+1)

퇴사
- N+1 일이 되는 날 퇴사를 하려고 한다 (1<=N<=15)
- 남은 N일 동안 최대한 많은 상담을 하려고 한다
- 하루에 하나의 상담을 할 수 있고, i일데 상담을 하면 T[i]일이 걸리고 P[i]원을 번다 
- 각각의 날마다 상담을 할지말지 결정 -> 2^N
- go(day, sum)
    - day일에 있는 상담을 할지 말지 결정
    - 지금까지 얻은 수익 : sum
- 정답을 찾은 경우
    - day == n+1
- 불가능한 경우
    - day > n+1
- 다음 경우 호출
    - 상담을 한다
        - go(day+T[day], sum + P[day])
    - 상담을 하지 않는다
        - go(day+1, sum)

**백트래킹**
- 더 이상 함수 호출이 의미 없을 때 이를 제외하는 것
- 함수의 호출이 진행되는 중에 정답을 못구할 것이라는 걸 알면 함수 호출 중단시킴

스타트와 링크
- N명을 N/2 명씩 두 팀으로 나눈다
- 두 팀의 능력치를 구한 다음, 차이의 최소값을 구하는 문제
- S[i][j] = i번 사람과 j번 사람이 같은 팀에 속했을 때, 팀에 더해지는 능력치
- 팀의 능력치 : 팀에 속한 모든 쌍의 S[i][j]의 합
- go(index, first, second)
    - index 번째 사람을 어떤 팀에 넣을지 결정
    - 1번 팀과 2번 팀에 속한 사람이 각각 first, second에 들어 있음
    - 정답을 찾은 경우
        - index == n
    - 다음 경우
        - 1번팀 : go(index, first, second)
        - 2번팀 : go(index, first, second)
        - 두 경우 모두 호출 전에 first 또는 second에 index를 넣고 호출 후에 빼는 과정 필요

부등호
- 부등호 기호가 나열된 수열 A가 있다
- 기호의 앞 뒤에 한 자리 숫자를 넣어서 모든 부등호 관계를 만족시키려고 한다
- 이 때 선택된 수는 모두 달라야 한다
- k개의 부등호 관계를 모두 만족시키는 (k+1)개 자리의 정수 중에서 최대값과 최소값을 구하는 문제
- 부등호의 자리가 있으면 넣을 수 있는 수 

맞춰봐
- -10부터 10까지의 N개의 정수(중복 없음)로 이루어진 수열 A가 있다
- S[i][j] = A[i] + A[i-1] + ... + A[j]가 0보다 크면 +, 작으면 -, 같으면 0
- S가 주어졌을 때, 가능한 A를 아무거나 찾는 문제
- 21개의 수를 10개의 자리에 넣어야 함 -> 21^10. 너무 큼. 못 푼다
- 중요한 부분 -> (i,i) 
    - s[i][i] = 0 -> 0
    - s[i][i] = + -> A[i] > 0
    - s[i][i] = - -> A[i] < 0
    - 10^10으로 줄일 수 있지만 이것도 너무 커서 못 푼다
- 수를 넣을 때 마다 검사한다
    - index번째 검사할 때 (0~index-1)까지 수가 결정됐다는 거니까 모든 sign[k][index]를 검사할 수 있다

---

비트마스크
- 비트 연산을 사용해서 부분 집합을 표현함
- 비트 연산
    - &, |, ~, ^
    - not 연산의 경우에는 자료형에 따라 결과가 달라진다.
    - 또 unsigned, signed에 따라서 보여지는 값이 다르다(내부 저장된 값은 똑같은데, 출력되는 값이 달라짐)
    - shift 연산 (<<, >>)
        - 3<<3 = 11000_(2)
        - A << B는 A x 2^B와 같다
        - A >> B는 A/2^B와 같다
        - (A+B) / 2 = (A+B)>>1로 쓸 수 있다
    - 연산자 우선순위 주의해야 함!!
- 정수로 집합을 나타낼 수 있다
    - {1,3,4,5,9} => {0,1,0,1,1,1,0,0,1} -> 비트로 표현해서 570이 나왔다
    - 장점
        - 배열이면 10개가 필요한데 정수 하나만 필요하다 -> 공간 절역
        - 정수라는 것이 장점. 배열의 인덱스로 쓸 수 있음
    - 사용하려는 수가 최대 몇 개가 있는지 알아야 함. 이 집합에 들어갈 수 있는 최댓값을 알아야 한다.
        - int 32비트
    - N개면 **무조건** 0~(N-1)
        - 1부터 N이 되면 공간이 2배 더 필요하다

비트마스크 검사 연산
- 어떤 비트 마스크에 어떤 수가 포함되어있는지 검사하는 연산
    - `and(&)` 연산 사용
- 0이 포함되어 있으면 2의 0번째 비트가 1이었을 것. 
- 2이 포함되어있는지 검사 : 2번째 비트가 1인지.
    - `570 & (1<<2)` -> 포함되어 있지 않으면 0이 나옴
- 3이 포함되어있는지 검사
    - `570 & 2^3 = 570 & (1<<3)` -> 포함되어 있으면 0이 아닌 값이 나옴. 실제로는 1<<3인 8이 나온다

추가 연산
- 그 비트를 1로 바꿔주면 된다
- 2 추가 하기
    - 2번째 비트를 1로 만든 연산과 or연산을 하면 됨
    - `570 | (1<<2)`
- 3 추가 하기
    - 이미 있는 걸 추가해도 됨
    - 추가를 알아서 무시하게 됨

제거하기
- 나머지를 다 1로만들고 제거하고 싶은 수를 0으로 만든 다음 not 연산
- 1 제거하기
    - `570 ^ 2^1 = 570 ^ (1<<1)`

토글하기
- xor 연산 사용
- 1 토글하기
    - `570 ^ 2^1 = 570 ^ (1<<1)`

전체 집합
- (1<<N) - 1

공집합
- 0

현재 집합이 S일 때
- i를 추가
    - S | (1 << i)
- i를 검사
    - S & (1 << i)
- i를 제거
    - S & ~(1 << i)
- i를 토글(0을 1로, 1을 0으로)
    - S ^ (1 << i)

비트마스크는 문제에 할 수 있는 게 N개가 있고, 그 때 일부를 선택해서 할 수 있을 때 모든 경우를 만드는 경우에 사용

항상 해야하는 일의 개수가 정해져 있고, 2^N으로 모든 상태를 만들 수 있으면 비트마스크 사용할 수 있다.

- 문제) 부분집합의 합
    - N개의 정수로 이루어진 수열이 있을 때, 크기가 양수인 부분수열 중에서 그 수열의 원소를 다 더한 값이 S가 되는 경우의 수를 구하는 프로그램
    - 모든 부분 수열은 2^N개 있음 -> 비트마스크로 표현 가능
    - 아무것도 포함되지 않은 것부터 모든 것이 포함될 때 까지...
        - `for(int i = 1; i<(1<<n); i++)`
        - 공집합은 제외해야하므로 i=1부터 시작
        - 재귀함수 없이 모든 부분 수열을 만들었다
    - 비트 연산에서 검사하는 연산 추가

- 문제) 스타트와 링크
    - 전체 경우의 수 2^N 이므로 순회 가능

- 문제) 종이 조각
    - N x M 크기의 종이를 조각으로 잘라서 합의 최대값을 구하는 문제
    - N, M이 매우 작음
    - 칸의 개수는 16보다 작음
        - 각각의 칸은 가로 또는 세로에 속하게 됨
        - 각각의 칸에 대해서 가로인지 세로인지 정하면 된다
        - 2^16 
    