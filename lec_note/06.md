# 코드플러스 알고리즘 기초 - 2/2
## 600 - 그래프

문제에 나와있는 상황을 그래프로 모델링하여 여러 가지 알고리즘을 수행함.
- 중요한 건, **어떻게 문제의 상황을 그래프로 만드는가**


그래프
- 정점
- 간선
- 특별한 말이 없으면, 일반적으로 사용하는 경로와 사이클은 단순 경로/사이클을 말함.
- 방향 없는 그래프
    - A->C, C->A 로 나타내야 한다.
- 가중치
- 차수 : 정점과 연결되어 있는 간선의 개수


그래프 저장 방법
- 인접 행렬
- 인접 리스트
- 효율 : 한 정점과 연결된 간선을 효율적으로 찾는 구조
- 그래프의 표현
    - 정점 -> 정점의 "수"로 바꾸면 됨


인접 행렬
- 정점의 개수를 V라고 했을 때, VxV 크기의 이차원 배열을 이용함
- A[i][j] = 1, 0, w
- 공간 복잡도 : O(V^2)


인접 리스트
- 리스트를 사용해서 구현
- A[i] = i와 연결된 정점과 그 간선의 가중치를 리스트로 포함하고 있음.
- 한 정점과 연결된 모든 간선을 찾는 시간 O(차수)
- 공간 복잡도 : O(E)
- vector, []


간선 리스트
- 배열을 이용해서 구현
- 간선을 모두 저장하고 있음
- 간선의 앞 정점을 기준으로 개수를 센다
- 앞 정점 기준으로 정렬한다
- cnt라는 배열에 합을 누적한다 
- i번 정점과 연결된 간선은 E배열에서 cnt[i-1]부터 cnt[i]-1까지이다.
- 잘 사용은 안하고, 인접리스트 해야 하는데 라이브러리 사용이 금지일 때 주로 사용


문제) ABCDE(13023)
- N명의 친구 관계가 주어졌을 때
- A - B - C - D - E 친구 관계가 존재하는지 구하는 문제
- A -> B -> C -> D 에서 길이가 4인 단순 경로를 찾고 D -> E를 찾는다.
- A -> B, C -> D 는 그냥 간선이기 때문에, 간선 리스트에서 찾을 수 있다.
- B -> C는 인접 행렬로 찾을 수 있다.
- D -> E는 인접 리스트로 찾는다


그래프의 탐색
- 목적 : 임의의 정점에서 시작하여 연결되어있는 모든 정점을 1번씩 방문하는 것
- DFS, BFS
    - 차이 : 어떤 순서로 정점 방문? 
- DFS : 깊이 우선 탐색 => stack
- BFS : 너비 우선 탐색 => queue


DFS : 깊이 우선 탐색
- 스택을 이용해서 갈 수 있는 만큼 최대한 가고, 갈 수 없으면 이전 정점으로 돌아간다
- 재귀 호출을 이용해서 구현할 수 있다.
- 인접 행렬을 이용한 구현
```cpp
void dfs(int x) {
    check[x] = true;
    for(int i = 1; i<=n; i++) {
        if(a[x][i] == 1 && check[i] == false) { // 간선이 있고, 방문하지 않았다면 ㄱ
            dfs(i);
        }
    }
}
```
- 인접 리스트를 이용한 구현
```cpp
void dfs(int x) {
    check[x] = true;
    for (int i =0; i<a[x].size(); i++) {
        int y = a[x][i];
        if(check[y] == false) {
            dfs(y);
        }
    }
}
```


**BFS : 너비 우선 탐색**
- 큐를 이용해서 지금 위치에서 갈 수 있는 것을 모두 큐에 넣는 방식
- *큐에 넣을 때 방문했다고 체크해야 한다.*
- 인접 행렬을 이용한 구현
```cpp
queue<int> q;
check[1] = true; q.push(1);
while (!q.empty()) {
    int x = q.front(); q.pop();
    for (int i = 1; i<=n; i++) {
        if(a[x][i] == 1 && check[i] == false) {
            check[i] = true;
            q.push(i);
        }
    }
}
```

- 인접 리스트를 이용한 구현
```cpp
queue<int> q;
check[1] = true; q.push(1);
while(!q.empty()) {
    int x = q.front(); q.pop();
    for (int i = 0; i<a[x].size(); i++) {
        int y = a[x][i];
        if (check[y] == false) {
            check[y] = true; q.push(y);
        }
    }
}
```

- 시간 복잡도
    - 인접 행렬 : O(V^2)
    - 인접 리스트 : O(V+E)



문제) DFS와 BFS(1260)


---
연결 요소
- 연결 요소가 2개 이상이다 => 끊어진 것임
- 연결 요소를 구하는 것은 DFS나 BFS 탐색을 이용해서 구할 수 있다.


**이분 그래프**
- 그래프를 A와 B로 나눌 수 있으면 이분 그래프라고 함.
- A에 포함되어 있는 정점끼리 연결된 간선이 없음
- B에 포함되어 있는 정점끼리 연결된 간선이 없음
- 모든 간선의 한 끝 점은 A에, 다른 끝 점은 B에
- 그래프를 DFS, BFS 탐색으로 이분 그래프인지 아닌지 알아낼 수 있다.


문제) 단지번호 붙이기
- 정사각형 모양의 지도가 있다.
- 지도를 가지고 연결된 집의 모임인 단지를 정의하고 단지에 번호를 붙인다
- 연결 요소의 개수, 크기를 구하는 문제로 볼 수 있음.
- DFS, BFS을 이용해서 어떻게 이어져있는지 확인할 수 있음.
- d[i][j] = (i,j) 를 방문안했으면 0, 했으면 단지 번호
- 매트릭스라고 생각해서 구한다


문제) 섬의 개수
- 방향이 8개임. list 추가해야 한다


문제) 미로 탐색
- (1,1)에서 (N,M)으로 가는 가장 빠른 길을 구하는 문제
- DFS 탐색으로는 문제를 풀 수 없음!
- BFS를 이용해야 한다
- BFS가 단계별로 진행된다는 사실을 이용. 최단거리를 의미함
