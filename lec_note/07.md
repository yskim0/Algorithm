# 코드플러스 알고리즘 기초 - 2/2
## 610 - BFS


BFS
- 임의의 정점에서 시작해서, 모든 정점을 한 번씩 방문하는 것이다.
- 모든 가중치가 1일 때, **최단 거리를 구하는 알고리즘이다.**
- BFS를 이용해 해결할 수 있는 문제는 아래와 같은 조건을 만족해야 한다.
    - 최소 비용 문제이어야 한다
    - 간선의 가중치가 1이어야 한다 
    - 정점과 간선의 개수가 적어야 한다.
        - E가 500만 정도를 max로 잡자
    - **간선의 가중치가 문제에서 구하라고 하는 최소 비용과 의미가 일치해야 한다.**
    - 즉 거리의 최소값을 구하는 문제라면 가중치는 거리를 의미해야 하고, 시간의 최소값을 구하는 문제라면 가중치는 시간을 의미해야 한다



문제) 숨바꼭질
- 동생을 찾는 가장 빠른 시간을 구하는 문제
- 수빈이가 할 수 있는 행동 : 위치 X
    - 걷기 X+1, X-1
    - 순간이동 2*X
- 수빈이의 위치 : 정점
- 위치 -> 위치 이동하는 것 : 간선
- 정점과 간선의 가중치가 모두 1, 가중치의 의미도 시간과 같은 의미이기 때문에 BFS로 풀 수 있다



문제) 숨바꼭질 4
- 이동하는 방법도 구해야 함
- 역추적하는 문제
- 왜 바뀌었는지 기록하면 됨
- 어디에서 왔는지!
- 역순으로 N이 될 때까지 찾아야 한다
    - 재귀함수
    - 반복문, stack
    ```cpp
    stack<int> ans;
    for(int i = m; i!=n; i=from[i]) {
        ans.push(i);
    }
    ans.push(n);
    while(!ans.empty()) {
        cout << ans.top() << ' ';
        ans.pop();
    }
    cout << '\n';
    ```


정점을 나눌 수 있다!!
문제) 이모티콘
- S개의 이모티콘을 만드는데 걸리는 시간의 최소값
- 할 수 있는 연산
    - 클립보드에 저장
    - 클립보드에 있는 모든 이모티콘을 붙여넣기
    - 화면에 있는 이모티콘 중 하나를 삭제
- 정점을 클립보드에 있는 개수와 함께 나누어져야 한다 (s,c)


---

BFS : 가중치가 1일 때. 사실 0,1일 때 구할 수 있다



문제) 숨바꼭질 3
- 순간이동할 때 0초가 걸린다는 점이 다름
- 다음 큐에 넣는 것을 덱의 뒤에 넣고, 현재 큐에 넣는 것을 덱의 앞에 넣으면 됨!


문제) 알고스팟
- 벽을 최소 몇 개 부수어야 하는지 구하는 문제
- 빈칸 -> 빈칸 : 가중치 0
- 빈칸 -> 벽 : 가중치 1
